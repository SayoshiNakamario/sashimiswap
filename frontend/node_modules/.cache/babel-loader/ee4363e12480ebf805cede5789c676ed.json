{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber'; // import Web3 from 'web3'\n\nimport * as Types from './types.js';\nimport { // SUBTRACT_GAS_LIMIT,\ncontractAddresses, supportedPools } from './constants.js';\nimport UNIV2PairAbi from './abi/uni_v2_lp.json';\nimport SushiAbi from './abi/sushi.json';\nimport MasterChefAbi from './abi/masterchef.json';\nimport ERC20Abi from './abi/erc20.json';\nimport WETHAbi from './abi/weth.json';\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3;\n    this.defaultConfirmations = options.defaultConfirmations;\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5;\n    this.confirmationType = options.confirmationType || Types.ConfirmationType.Confirmed;\n    this.defaultGas = options.defaultGas;\n    this.defaultGasPrice = options.defaultGasPrice;\n    this.sushi = new this.web3.eth.Contract(SushiAbi);\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi);\n    this.weth = new this.web3.eth.Contract(WETHAbi);\n    this.pools = supportedPools.map(pool => Object.assign(pool, {\n      lpAddress: pool.lpAddresses[networkId],\n      tokenAddress: pool.tokenAddresses[networkId],\n      lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n      tokenContract: new this.web3.eth.Contract(ERC20Abi)\n    }));\n    this.setProvider(provider, networkId);\n    this.setDefaultAccount(this.web3.eth.defaultAccount);\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider);\n      if (address) contract.options.address = address;else console.error('Contract address not found in network', networkId);\n    };\n\n    setProvider(this.sushi, contractAddresses.sushi[networkId]);\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId]);\n    setProvider(this.weth, contractAddresses.weth[networkId]);\n    this.pools.forEach(({\n      lpContract,\n      lpAddress,\n      tokenContract,\n      tokenAddress\n    }) => {\n      setProvider(lpContract, lpAddress);\n      setProvider(tokenContract, tokenAddress);\n    });\n  }\n\n  setDefaultAccount(account) {\n    this.sushi.options.from = account;\n    this.masterChef.options.from = account;\n  } // async callContractFunction(method, options) {\n  //   const {\n  //     confirmations,\n  //     confirmationType,\n  //     autoGasMultiplier,\n  //     ...txOptions\n  //   } = options\n  //\n  //   if (!this.blockGasLimit) {\n  //     await this.setGasLimit()\n  //   }\n  //\n  //   if (!txOptions.gasPrice && this.defaultGasPrice) {\n  //     txOptions.gasPrice = this.defaultGasPrice\n  //   }\n  //\n  //   if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n  //     let gasEstimate\n  //     if (\n  //       this.defaultGas &&\n  //       confirmationType !== Types.ConfirmationType.Simulate\n  //     ) {\n  //       txOptions.gas = this.defaultGas\n  //     } else {\n  //       try {\n  //         console.log('estimating gas')\n  //         gasEstimate = await method.estimateGas(txOptions)\n  //       } catch (error) {\n  //         const data = method.encodeABI()\n  //         const { from, value } = options\n  //         const to = method._parent._address\n  //         error.transactionData = { from, value, data, to }\n  //         throw error\n  //       }\n  //\n  //       const multiplier = autoGasMultiplier || this.autoGasMultiplier\n  //       const totalGas = Math.floor(gasEstimate * multiplier)\n  //       txOptions.gas =\n  //         totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\n  //     }\n  //\n  //     if (confirmationType === Types.ConfirmationType.Simulate) {\n  //       let g = txOptions.gas\n  //       return { gasEstimate, g }\n  //     }\n  //   }\n  //\n  //   if (txOptions.value) {\n  //     txOptions.value = new BigNumber(txOptions.value).toFixed(0)\n  //   } else {\n  //     txOptions.value = '0'\n  //   }\n  //\n  //   const promi = method.send(txOptions)\n  //\n  //   const OUTCOMES = {\n  //     INITIAL: 0,\n  //     RESOLVED: 1,\n  //     REJECTED: 2,\n  //   }\n  //\n  //   let hashOutcome = OUTCOMES.INITIAL\n  //   let confirmationOutcome = OUTCOMES.INITIAL\n  //\n  //   const t =\n  //     confirmationType !== undefined ? confirmationType : this.confirmationType\n  //\n  //   if (!Object.values(Types.ConfirmationType).includes(t)) {\n  //     throw new Error(`Invalid confirmation type: ${t}`)\n  //   }\n  //\n  //   let hashPromise\n  //   let confirmationPromise\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Hash ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     hashPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       promi.on('transactionHash', (txHash) => {\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\n  //           hashOutcome = OUTCOMES.RESOLVED\n  //           resolve(txHash)\n  //           if (t !== Types.ConfirmationType.Both) {\n  //             const anyPromi = promi\n  //             anyPromi.off()\n  //           }\n  //         }\n  //       })\n  //     })\n  //   }\n  //\n  //   if (\n  //     t === Types.ConfirmationType.Confirmed ||\n  //     t === Types.ConfirmationType.Both\n  //   ) {\n  //     confirmationPromise = new Promise((resolve, reject) => {\n  //       promi.on('error', (error) => {\n  //         if (\n  //           (t === Types.ConfirmationType.Confirmed ||\n  //             hashOutcome === OUTCOMES.RESOLVED) &&\n  //           confirmationOutcome === OUTCOMES.INITIAL\n  //         ) {\n  //           confirmationOutcome = OUTCOMES.REJECTED\n  //           reject(error)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         }\n  //       })\n  //\n  //       const desiredConf = confirmations || this.defaultConfirmations\n  //       if (desiredConf) {\n  //         promi.on('confirmation', (confNumber, receipt) => {\n  //           if (confNumber >= desiredConf) {\n  //             if (confirmationOutcome === OUTCOMES.INITIAL) {\n  //               confirmationOutcome = OUTCOMES.RESOLVED\n  //               resolve(receipt)\n  //               const anyPromi = promi\n  //               anyPromi.off()\n  //             }\n  //           }\n  //         })\n  //       } else {\n  //         promi.on('receipt', (receipt) => {\n  //           confirmationOutcome = OUTCOMES.RESOLVED\n  //           resolve(receipt)\n  //           const anyPromi = promi\n  //           anyPromi.off()\n  //         })\n  //       }\n  //     })\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Hash) {\n  //     const transactionHash = await hashPromise\n  //     if (this.notifier) {\n  //       this.notifier.hash(transactionHash)\n  //     }\n  //     return { transactionHash }\n  //   }\n  //\n  //   if (t === Types.ConfirmationType.Confirmed) {\n  //     return confirmationPromise\n  //   }\n  //\n  //   const transactionHash = await hashPromise\n  //   if (this.notifier) {\n  //     this.notifier.hash(transactionHash)\n  //   }\n  //   return {\n  //     transactionHash,\n  //     confirmation: confirmationPromise,\n  //   }\n  // }\n  // async callConstantContractFunction(method, options) {\n  //   const m2 = method\n  //   const { blockNumber, ...txOptions } = options\n  //   return m2.call(txOptions, blockNumber)\n  // }\n  // async setGasLimit() {\n  //   const block = await this.web3.eth.getBlock('latest')\n  //   this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\n  // }\n\n\n}","map":{"version":3,"sources":["C:/Users/Kyle/Documents/FOGmist/sashimiswap/frontend/src/sushi/lib/contracts.js"],"names":["BigNumber","Types","contractAddresses","supportedPools","UNIV2PairAbi","SushiAbi","MasterChefAbi","ERC20Abi","WETHAbi","Contracts","constructor","provider","networkId","web3","options","defaultConfirmations","autoGasMultiplier","confirmationType","ConfirmationType","Confirmed","defaultGas","defaultGasPrice","sushi","eth","Contract","masterChef","weth","pools","map","pool","Object","assign","lpAddress","lpAddresses","tokenAddress","tokenAddresses","lpContract","tokenContract","setProvider","setDefaultAccount","defaultAccount","contract","address","console","error","forEach","account","from"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAhOqB","sourcesContent":["import BigNumber from 'bignumber.js/bignumber'\r\n// import Web3 from 'web3'\r\nimport * as Types from './types.js'\r\nimport {\r\n  // SUBTRACT_GAS_LIMIT,\r\n  contractAddresses,\r\n  supportedPools,\r\n} from './constants.js'\r\n\r\nimport UNIV2PairAbi from './abi/uni_v2_lp.json'\r\n\r\nimport SushiAbi from './abi/sushi.json'\r\nimport MasterChefAbi from './abi/masterchef.json'\r\nimport ERC20Abi from './abi/erc20.json'\r\nimport WETHAbi from './abi/weth.json'\r\n\r\nexport class Contracts {\r\n  constructor(provider, networkId, web3, options) {\r\n    this.web3 = web3\r\n    this.defaultConfirmations = options.defaultConfirmations\r\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5\r\n    this.confirmationType =\r\n      options.confirmationType || Types.ConfirmationType.Confirmed\r\n    this.defaultGas = options.defaultGas\r\n    this.defaultGasPrice = options.defaultGasPrice\r\n\r\n    this.sushi = new this.web3.eth.Contract(SushiAbi)\r\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi)\r\n    this.weth = new this.web3.eth.Contract(WETHAbi)\r\n\r\n    this.pools = supportedPools.map((pool) =>\r\n      Object.assign(pool, {\r\n        lpAddress: pool.lpAddresses[networkId],\r\n        tokenAddress: pool.tokenAddresses[networkId],\r\n        lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\r\n        tokenContract: new this.web3.eth.Contract(ERC20Abi),\r\n      }),\r\n    )\r\n\r\n    this.setProvider(provider, networkId)\r\n    this.setDefaultAccount(this.web3.eth.defaultAccount)\r\n  }\r\n\r\n  setProvider(provider, networkId) {\r\n    const setProvider = (contract, address) => {\r\n      contract.setProvider(provider)\r\n      if (address) contract.options.address = address\r\n      else console.error('Contract address not found in network', networkId)\r\n    }\r\n\r\n    setProvider(this.sushi, contractAddresses.sushi[networkId])\r\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId])\r\n    setProvider(this.weth, contractAddresses.weth[networkId])\r\n\r\n    this.pools.forEach(\r\n      ({ lpContract, lpAddress, tokenContract, tokenAddress }) => {\r\n        setProvider(lpContract, lpAddress)\r\n        setProvider(tokenContract, tokenAddress)\r\n      },\r\n    )\r\n  }\r\n\r\n  setDefaultAccount(account) {\r\n    this.sushi.options.from = account\r\n    this.masterChef.options.from = account\r\n  }\r\n\r\n  // async callContractFunction(method, options) {\r\n  //   const {\r\n  //     confirmations,\r\n  //     confirmationType,\r\n  //     autoGasMultiplier,\r\n  //     ...txOptions\r\n  //   } = options\r\n  //\r\n  //   if (!this.blockGasLimit) {\r\n  //     await this.setGasLimit()\r\n  //   }\r\n  //\r\n  //   if (!txOptions.gasPrice && this.defaultGasPrice) {\r\n  //     txOptions.gasPrice = this.defaultGasPrice\r\n  //   }\r\n  //\r\n  //   if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\r\n  //     let gasEstimate\r\n  //     if (\r\n  //       this.defaultGas &&\r\n  //       confirmationType !== Types.ConfirmationType.Simulate\r\n  //     ) {\r\n  //       txOptions.gas = this.defaultGas\r\n  //     } else {\r\n  //       try {\r\n  //         console.log('estimating gas')\r\n  //         gasEstimate = await method.estimateGas(txOptions)\r\n  //       } catch (error) {\r\n  //         const data = method.encodeABI()\r\n  //         const { from, value } = options\r\n  //         const to = method._parent._address\r\n  //         error.transactionData = { from, value, data, to }\r\n  //         throw error\r\n  //       }\r\n  //\r\n  //       const multiplier = autoGasMultiplier || this.autoGasMultiplier\r\n  //       const totalGas = Math.floor(gasEstimate * multiplier)\r\n  //       txOptions.gas =\r\n  //         totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\r\n  //     }\r\n  //\r\n  //     if (confirmationType === Types.ConfirmationType.Simulate) {\r\n  //       let g = txOptions.gas\r\n  //       return { gasEstimate, g }\r\n  //     }\r\n  //   }\r\n  //\r\n  //   if (txOptions.value) {\r\n  //     txOptions.value = new BigNumber(txOptions.value).toFixed(0)\r\n  //   } else {\r\n  //     txOptions.value = '0'\r\n  //   }\r\n  //\r\n  //   const promi = method.send(txOptions)\r\n  //\r\n  //   const OUTCOMES = {\r\n  //     INITIAL: 0,\r\n  //     RESOLVED: 1,\r\n  //     REJECTED: 2,\r\n  //   }\r\n  //\r\n  //   let hashOutcome = OUTCOMES.INITIAL\r\n  //   let confirmationOutcome = OUTCOMES.INITIAL\r\n  //\r\n  //   const t =\r\n  //     confirmationType !== undefined ? confirmationType : this.confirmationType\r\n  //\r\n  //   if (!Object.values(Types.ConfirmationType).includes(t)) {\r\n  //     throw new Error(`Invalid confirmation type: ${t}`)\r\n  //   }\r\n  //\r\n  //   let hashPromise\r\n  //   let confirmationPromise\r\n  //\r\n  //   if (\r\n  //     t === Types.ConfirmationType.Hash ||\r\n  //     t === Types.ConfirmationType.Both\r\n  //   ) {\r\n  //     hashPromise = new Promise((resolve, reject) => {\r\n  //       promi.on('error', (error) => {\r\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\r\n  //           hashOutcome = OUTCOMES.REJECTED\r\n  //           reject(error)\r\n  //           const anyPromi = promi\r\n  //           anyPromi.off()\r\n  //         }\r\n  //       })\r\n  //\r\n  //       promi.on('transactionHash', (txHash) => {\r\n  //         if (hashOutcome === OUTCOMES.INITIAL) {\r\n  //           hashOutcome = OUTCOMES.RESOLVED\r\n  //           resolve(txHash)\r\n  //           if (t !== Types.ConfirmationType.Both) {\r\n  //             const anyPromi = promi\r\n  //             anyPromi.off()\r\n  //           }\r\n  //         }\r\n  //       })\r\n  //     })\r\n  //   }\r\n  //\r\n  //   if (\r\n  //     t === Types.ConfirmationType.Confirmed ||\r\n  //     t === Types.ConfirmationType.Both\r\n  //   ) {\r\n  //     confirmationPromise = new Promise((resolve, reject) => {\r\n  //       promi.on('error', (error) => {\r\n  //         if (\r\n  //           (t === Types.ConfirmationType.Confirmed ||\r\n  //             hashOutcome === OUTCOMES.RESOLVED) &&\r\n  //           confirmationOutcome === OUTCOMES.INITIAL\r\n  //         ) {\r\n  //           confirmationOutcome = OUTCOMES.REJECTED\r\n  //           reject(error)\r\n  //           const anyPromi = promi\r\n  //           anyPromi.off()\r\n  //         }\r\n  //       })\r\n  //\r\n  //       const desiredConf = confirmations || this.defaultConfirmations\r\n  //       if (desiredConf) {\r\n  //         promi.on('confirmation', (confNumber, receipt) => {\r\n  //           if (confNumber >= desiredConf) {\r\n  //             if (confirmationOutcome === OUTCOMES.INITIAL) {\r\n  //               confirmationOutcome = OUTCOMES.RESOLVED\r\n  //               resolve(receipt)\r\n  //               const anyPromi = promi\r\n  //               anyPromi.off()\r\n  //             }\r\n  //           }\r\n  //         })\r\n  //       } else {\r\n  //         promi.on('receipt', (receipt) => {\r\n  //           confirmationOutcome = OUTCOMES.RESOLVED\r\n  //           resolve(receipt)\r\n  //           const anyPromi = promi\r\n  //           anyPromi.off()\r\n  //         })\r\n  //       }\r\n  //     })\r\n  //   }\r\n  //\r\n  //   if (t === Types.ConfirmationType.Hash) {\r\n  //     const transactionHash = await hashPromise\r\n  //     if (this.notifier) {\r\n  //       this.notifier.hash(transactionHash)\r\n  //     }\r\n  //     return { transactionHash }\r\n  //   }\r\n  //\r\n  //   if (t === Types.ConfirmationType.Confirmed) {\r\n  //     return confirmationPromise\r\n  //   }\r\n  //\r\n  //   const transactionHash = await hashPromise\r\n  //   if (this.notifier) {\r\n  //     this.notifier.hash(transactionHash)\r\n  //   }\r\n  //   return {\r\n  //     transactionHash,\r\n  //     confirmation: confirmationPromise,\r\n  //   }\r\n  // }\r\n\r\n  // async callConstantContractFunction(method, options) {\r\n  //   const m2 = method\r\n  //   const { blockNumber, ...txOptions } = options\r\n  //   return m2.call(txOptions, blockNumber)\r\n  // }\r\n\r\n  // async setGasLimit() {\r\n  //   const block = await this.web3.eth.getBlock('latest')\r\n  //   this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\r\n  // }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}