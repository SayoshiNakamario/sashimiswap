"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPriorityConnector = exports.initializeConnector = void 0;
const providers_1 = require("@ethersproject/providers");
const store_1 = require("@web3-react/store");
const react_1 = require("react");
const zustand_1 = __importDefault(require("zustand"));
/**
 * Wraps the initialization of a `connector`. Creates a zustand `store` with `actions` bound to it, and then passes
 * these to the connector as specified in `f`. Also creates a variety of `hooks` bound to this `store`.
 *
 * @typeParam T - The type of the `connector` returned from `f`.
 * @param f - A function which is called with `actions` bound to the returned `store`.
 * @param allowedChainIds - An optional array of chainIds which the `connector` may connect to. If the `connector` is
 * connected to a chainId which is not allowed, a ChainIdNotAllowedError error will be reported.
 * If this argument is unspecified, the `connector` may connect to any chainId.
 * @returns [connector, hooks, store] - The initialized connector, a variety of hooks, and a zustand store.
 */
function initializeConnector(f, allowedChainIds) {
    const [store, actions] = (0, store_1.createWeb3ReactStoreAndActions)(allowedChainIds);
    const connector = f(actions);
    const useConnector = (0, zustand_1.default)(store);
    const stateHooks = getStateHooks(useConnector);
    const derivedHooks = getDerivedHooks(stateHooks);
    const augmentedHooks = getAugmentedHooks(connector, stateHooks, derivedHooks);
    return [connector, Object.assign(Object.assign(Object.assign({}, stateHooks), derivedHooks), augmentedHooks), store];
}
exports.initializeConnector = initializeConnector;
function computeIsActive({ chainId, accounts, activating, error }) {
    return Boolean(chainId && accounts && !activating && !error);
}
/**
 * Creates a variety of convenience `hooks` that return data associated with the first of the `initializedConnectors`
 * that is active.
 *
 * @param initializedConnectors - Two or more [connector, hooks] arrays, as returned from initializeConnector.
 * @returns hooks - A variety of convenience hooks that wrap the hooks returned from initializeConnector.
 */
function getPriorityConnector(...initializedConnectors) {
    // the following code calls hooks in a map a lot, which violates the eslint rule.
    // this is ok, though, because initializedConnectors never changes, so the same hooks are called each time
    function useActiveIndex() {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());
        const index = values.findIndex((isActive) => isActive);
        return index === -1 ? undefined : index;
    }
    function usePriorityConnector() {
        var _a;
        return initializedConnectors[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0][0];
    }
    function usePriorityChainId() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useChainId }]) => useChainId());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityAccounts() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useAccounts }]) => useAccounts());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityIsActivating() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useIsActivating }]) => useIsActivating());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityError() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useError }]) => useError());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityAccount() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useAccount }]) => useAccount());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityIsActive() {
        var _a;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());
        return values[(_a = useActiveIndex()) !== null && _a !== void 0 ? _a : 0];
    }
    function usePriorityProvider(network) {
        const index = useActiveIndex();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useProvider }], i) => useProvider(network, i === index));
        return values[index !== null && index !== void 0 ? index : 0];
    }
    function usePriorityENSNames(provider) {
        const index = useActiveIndex();
        const values = initializedConnectors.map(([, { useENSNames }], i) => 
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useENSNames(i === index ? provider : undefined));
        return values[index !== null && index !== void 0 ? index : 0];
    }
    function usePriorityENSName(provider) {
        const index = useActiveIndex();
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const values = initializedConnectors.map(([, { useENSName }], i) => useENSName(i === index ? provider : undefined));
        return values[index !== null && index !== void 0 ? index : 0];
    }
    function usePriorityWeb3React(provider) {
        const index = useActiveIndex();
        const values = initializedConnectors.map(([, { useWeb3React }], i) => 
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useWeb3React(i === index ? provider : undefined));
        return values[index !== null && index !== void 0 ? index : 0];
    }
    return {
        usePriorityConnector,
        usePriorityChainId,
        usePriorityAccounts,
        usePriorityIsActivating,
        usePriorityError,
        usePriorityAccount,
        usePriorityIsActive,
        usePriorityProvider,
        usePriorityENSNames,
        usePriorityENSName,
        usePriorityWeb3React,
    };
}
exports.getPriorityConnector = getPriorityConnector;
const CHAIN_ID = (state) => state.chainId;
const ACCOUNTS = (state) => state.accounts;
const ACCOUNTS_EQUALITY_CHECKER = (oldAccounts, newAccounts) => (oldAccounts === undefined && newAccounts === undefined) ||
    (oldAccounts !== undefined &&
        oldAccounts.length === (newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts.length) &&
        oldAccounts.every((oldAccount, i) => oldAccount === newAccounts[i]));
const ACTIVATING = (state) => state.activating;
const ERROR = (state) => state.error;
function getStateHooks(useConnector) {
    function useChainId() {
        return useConnector(CHAIN_ID);
    }
    function useAccounts() {
        return useConnector(ACCOUNTS, ACCOUNTS_EQUALITY_CHECKER);
    }
    function useIsActivating() {
        return useConnector(ACTIVATING);
    }
    function useError() {
        return useConnector(ERROR);
    }
    return { useChainId, useAccounts, useIsActivating, useError };
}
function getDerivedHooks({ useChainId, useAccounts, useIsActivating, useError }) {
    function useAccount() {
        var _a;
        return (_a = useAccounts()) === null || _a === void 0 ? void 0 : _a[0];
    }
    function useIsActive() {
        const chainId = useChainId();
        const accounts = useAccounts();
        const activating = useIsActivating();
        const error = useError();
        return computeIsActive({
            chainId,
            accounts,
            activating,
            error,
        });
    }
    return { useAccount, useIsActive };
}
function useENS(provider, accounts) {
    const [ENSNames, setENSNames] = (0, react_1.useState)();
    (0, react_1.useEffect)(() => {
        if (provider && (accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
            let stale = false;
            Promise.all(accounts.map((account) => provider.lookupAddress(account)))
                .then((ENSNames) => {
                if (!stale) {
                    setENSNames(ENSNames);
                }
            })
                .catch((error) => {
                console.debug('Could not fetch ENS names', error);
            });
            return () => {
                stale = true;
                setENSNames(undefined);
            };
        }
    }, [provider, accounts]);
    return ENSNames;
}
function getAugmentedHooks(connector, { useChainId, useAccounts, useError }, { useAccount, useIsActive }) {
    function useProvider(network, enabled = true) {
        const isActive = useIsActive();
        const chainId = useChainId();
        const accounts = useAccounts();
        return (0, react_1.useMemo)(() => {
            // we use chainId and accounts to re-render in case connector.provider changes in place
            if (enabled && isActive && connector.provider && chainId && accounts) {
                return new providers_1.Web3Provider(connector.provider, network);
            }
        }, [enabled, isActive, network, chainId, accounts]);
    }
    function useENSNames(provider) {
        const accounts = useAccounts();
        return useENS(provider, accounts);
    }
    function useENSName(provider) {
        var _a;
        const account = useAccount();
        const accounts = (0, react_1.useMemo)(() => (account === undefined ? undefined : [account]), [account]);
        return (_a = useENS(provider, accounts)) === null || _a === void 0 ? void 0 : _a[0];
    }
    // for backwards compatibility only
    function useWeb3React(provider) {
        const chainId = useChainId();
        const account = useAccount();
        const error = useError();
        const isActive = useIsActive();
        return (0, react_1.useMemo)(() => ({
            connector,
            library: provider,
            chainId,
            account,
            active: isActive,
            error,
        }), [provider, chainId, account, isActive, error]);
    }
    return { useProvider, useENSNames, useENSName, useWeb3React };
}
